<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>three-vrm example</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <style>
      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #divInfo {
        padding: 8px;
        position: fixed;
        background: white;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.7.4/esm/browser.js",
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
          "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.4/lib/three-vrm.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { VRMLoaderPlugin, VRMUtils } from "@pixiv/three-vrm";
      import { loadMixamoAnimation } from "./three-vrm-3.4.4/packages/three-vrm/examples/humanoidAnimation/loadMixamoAnimation.js";
      import GUI from "three/addons/libs/lil-gui.module.min.js";

      let renderer;
      let camera;
      let controls;
      let scene;
      let light;
      let lookAtTarget;

      // config
      const defaultModelUrl = "./AvatarSample_A.vrm";

      function init() {
        // renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 1);
        document.body.appendChild(renderer.domElement);

        // camera
        camera = new THREE.PerspectiveCamera(
          30.0,
          window.innerWidth / window.innerHeight,
          0.1,
          20.0
        );
        camera.position.set(0.0, 1.0, 5.0);

        // camera controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 1.0, 0.0);
        controls.update();

        // scene
        scene = new THREE.Scene();

        // light
        light = new THREE.DirectionalLight(0xffffff, Math.PI);
        light.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(light);

        // lookat target
        lookAtTarget = new THREE.Object3D();
        camera.add(lookAtTarget);
      }

      init();

      // Animation varibles
      let currentVrm = undefined;
      let currentAnimationUrl = undefined;
      let currentMixer = undefined;
      let currentAction = undefined;

      function loadVRM(modelUrl) {
        const loader = new GLTFLoader();
        loader.crossOrigin = "anonymous";

        loader.register((parser) => {
          return new VRMLoaderPlugin(parser, {
            autoUpdateHumanBones: true,
          });
        });

        loader.load(modelUrl, async (gltf) => {
          const vrm = gltf.userData.vrm;

          VRMUtils.removeUnnecessaryVertices(gltf.scene);
          VRMUtils.combineSkeletons(gltf.scene);
          VRMUtils.combineMorphs(vrm);

          if (currentVrm) {
            scene.remove(currentVrm.scene);
            VRMUtils.deepDispose(currentVrm.scene);
          }

          currentVrm = vrm;
          vrm.lookAt.target = lookAtTarget;
          scene.add(vrm.scene);

          currentMixer = new THREE.AnimationMixer(currentVrm.scene);

          vrm.scene.traverse((obj) => {
            obj.frustumCulled = false;
          });

          VRMUtils.rotateVRM0(vrm);

          await loadAnimations(animationUrls);
        });
      }

      loadVRM(defaultModelUrl);

      const animationUrls = [
        "./animations/Idle.fbx",
        "./animations/Breathing Idle.fbx",
      ];

      const loadedActions = [];

      async function loadAnimations(urls) {
        for (const url of urls) {
          const clip = await loadMixamoAnimation(url, currentVrm);
          const action = currentMixer.clipAction(clip);

          action.reset();
          action.setLoop(THREE.LoopOnce, 0);
          action.clampWhenFinished = true;

          loadedActions.push(action);
        }
      }

      // animate
      const clock = new THREE.Clock();

      // blink varibles
      let nextBlinkTime = 0;
      let blinkDuration = 0.1;
      let isBlinking = false;
      let blinkStartTime = 0;

      //  idle animation varibles
      let nextAnimationTime = 0;
      const minAnimationInterval = 1;
      const maxAnimationInterval = 8;
      let isAnimating = false;

      // talking varibles
      let audioContext;
      let analyser;
      let audioSource;
      let audioElement;
      let lipSyncActive = false;
      const lipSyncData = new Uint8Array(128);

      function playAudioWithLipSync(mp3Url) {
        if (!currentVrm) return;

        // Initialize AudioContext if needed
        if (!audioContext) {
          audioContext = new AudioContext();
        }

        // Create or reuse audio element
        audioElement = new Audio(mp3Url);
        audioElement.crossOrigin = "anonymous";

        // Connect audio to analyser
        audioSource = audioContext.createMediaElementSource(audioElement);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;

        audioSource.connect(analyser);
        analyser.connect(audioContext.destination);

        // Start playback
        audioElement.play();
        lipSyncActive = true;

        // When audio ends, stop lip-sync
        audioElement.onended = () => {
          lipSyncActive = false;

          // Reset mouth expressions
          currentVrm.expressionManager.setValue("aa", 0);
          currentVrm.expressionManager.setValue("oh", 0);
          currentVrm.expressionManager.setValue("ee", 0);
        };
      }

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();

        updateMixer(deltaTime);
        updateBlink();
        updateRandomIdleAnimation();

        if (lipSyncActive && analyser) {
          analyser.getByteFrequencyData(lipSyncData);

          let sum = 0;
          for (let i = 0; i < lipSyncData.length; i++) {
            sum += lipSyncData[i];
          }

          const volume = sum / lipSyncData.length / 255;

          // Map volume to mouth expressions
          const mouthOpen = THREE.MathUtils.clamp(volume * 2.5, 0, 1);

          currentVrm.expressionManager.setValue("aa", mouthOpen);
          currentVrm.expressionManager.setValue("oh", mouthOpen * 0.5);
          currentVrm.expressionManager.setValue("ee", mouthOpen * 0.3);
        }

        if (currentVrm) {
          currentVrm.update(deltaTime);
        }

        renderer.render(scene, camera);
      }

      function updateMixer(deltaTime) {
        if (currentMixer) {
          currentMixer.update(deltaTime);
        }
      }

      function updateBlink() {
        if (!currentVrm) return;

        const time = clock.elapsedTime;

        if (!isBlinking && time > nextBlinkTime) {
          isBlinking = true;
          blinkStartTime = time;
          blinkDuration = 0.05 + Math.random() * 0.1;
          nextBlinkTime = time + 1 + Math.random() * 3;
        }

        let blinkValue = 0;
        if (isBlinking) {
          let t = (time - blinkStartTime) / blinkDuration;
          if (t >= 1) {
            t = 1;
            isBlinking = false;
          }
          blinkValue = Math.sin(Math.PI * t);
        }

        currentVrm.expressionManager.setValue("blinkLeft", blinkValue);
        currentVrm.expressionManager.setValue("blinkRight", blinkValue);
      }

      function updateRandomIdleAnimation() {
        if (
          !currentVrm ||
          isAnimating ||
          lipSyncActive ||
          Object.keys(loadedActions).length === 0
        )
          return;

        const time = clock.elapsedTime;

        if (time <= nextAnimationTime) return;

        isAnimating = true;
        const keys = Object.keys(loadedActions);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        const action = loadedActions[randomKey];

        action.reset();
        action.setLoop(THREE.LoopOnce, 0);
        action.clampWhenFinished = true;
        action.play();

        const duration = action._clip.duration;
        setTimeout(() => {
          isAnimating = false;
          nextAnimationTime =
            time +
            duration +
            minAnimationInterval +
            Math.random() * (maxAnimationInterval - minAnimationInterval);
        }, duration * 1000);
      }

      animate();

      document.addEventListener("click", () => {
        playAudioWithLipSync("./ttsmaker-file-2025-12-13-11-59-56.mp3"); // Lip-sync test
      });

      // mouse listener
      window.addEventListener("mousemove", (event) => {
        lookAtTarget.position.x =
          10.0 *
          ((event.clientX - 0.5 * window.innerWidth) / window.innerHeight);
        lookAtTarget.position.y =
          -10.0 *
          ((event.clientY - 0.5 * window.innerHeight) / window.innerHeight);
      });

      document.addEventListener("mouseout", (event) => {
        // If relatedTarget is null, the mouse left the document (browser window/viewport)
        // and event.clientX/Y can help you confirm which edge it left through
        if (!event.relatedTarget && !event.toElement) {
          // Mouse left the browser window
          // console.log("Mouse left the screen!");

          // Reset lookAtTarget
          lookAtTarget.position.x = 0;
          lookAtTarget.position.y = 0;
        }
      });
    </script>
  </body>
</html>
