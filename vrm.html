<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>three-vrm example</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <style>
      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #divInfo {
        padding: 8px;
        position: fixed;
        background: white;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.7.4/esm/browser.js",
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
          "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.4/lib/three-vrm.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { VRMLoaderPlugin, VRMUtils } from "@pixiv/three-vrm";
      import { loadMixamoAnimation } from "./three-vrm-3.4.4/packages/three-vrm/examples/humanoidAnimation/loadMixamoAnimation.js";
      import GUI from "three/addons/libs/lil-gui.module.min.js";

      // renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0xffffff, 1); // 0xffffff
      document.body.appendChild(renderer.domElement);

      // camera
      const camera = new THREE.PerspectiveCamera(
        30.0,
        window.innerWidth / window.innerHeight,
        0.1,
        20.0
      );
      camera.position.set(0.0, 1.0, 5.0);

      // camera controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.screenSpacePanning = true;
      controls.target.set(0.0, 1.0, 0.0);
      controls.update();

      // scene
      const scene = new THREE.Scene();

      // light
      const light = new THREE.DirectionalLight(0xffffff, Math.PI);
      light.position.set(1.0, 1.0, 1.0).normalize();
      scene.add(light);

      // lookat target
      const lookAtTarget = new THREE.Object3D();
      camera.add(lookAtTarget);

      const defaultModelUrl = "./AvatarSample_A.vrm";

      // gltf and vrm
      let currentVrm = undefined;
      let currentAnimationUrl = undefined;
      let currentMixer = undefined;
      let currentAction = undefined;

      //   const helperRoot = new THREE.Group();
      //   helperRoot.renderOrder = 10000;
      //   scene.add(helperRoot);

      function loadVRM(modelUrl) {
        const loader = new GLTFLoader();
        loader.crossOrigin = "anonymous";

        // helperRoot.clear();

        loader.register((parser) => {
          return new VRMLoaderPlugin(parser, {
            // helperRoot: helperRoot,
            autoUpdateHumanBones: true,
          });
        });

        loader.load(
          // URL of the VRM you want to load
          modelUrl,

          // called when the resource is loaded
          (gltf) => {
            const vrm = gltf.userData.vrm;

            // calling this function greatly improves the performance
            VRMUtils.removeUnnecessaryVertices(gltf.scene);
            VRMUtils.combineSkeletons(gltf.scene);
            VRMUtils.combineMorphs(vrm);

            if (currentVrm) {
              scene.remove(currentVrm.scene);

              VRMUtils.deepDispose(currentVrm.scene);
            }

            // put the model to the scene
            currentVrm = vrm;
            vrm.lookAt.target = lookAtTarget;

            scene.add(vrm.scene);

            // create AnimationMixer for VRM
            currentMixer = new THREE.AnimationMixer(currentVrm.scene);

            // Disable frustum culling
            vrm.scene.traverse((obj) => {
              obj.frustumCulled = false;
            });

            if (currentAnimationUrl) {
              loadFBX(currentAnimationUrl);
            }

            // rotate if the VRM is VRM0.0
            VRMUtils.rotateVRM0(vrm);

            console.log(vrm);
          },

          // called while loading is progressing
          (progress) =>
            console.log(
              "Loading model...",
              100.0 * (progress.loaded / progress.total),
              "%"
            ),

          // called when loading has errors
          (error) => console.error(error)
        );
      }

      loadVRM(defaultModelUrl);

      // mixamo animation
      async function loadFBX(animationUrl) {
        currentAnimationUrl = animationUrl;

        if (currentMixer) {
          // Load animation
          const clip = await loadMixamoAnimation(animationUrl, currentVrm);

          const newAction = currentMixer.clipAction(clip);
          newAction.reset();

          // Stop the animation from looping
          newAction.setLoop(THREE.LoopOnce, 0);
          newAction.clampWhenFinished = false;

          newAction.play();

          if (currentAction && currentAction !== newAction) {
            currentAction.crossFadeTo(newAction, 0.5, false);
          }

          currentAction = newAction;
        }
      }

      // helpers
      //   const gridHelper = new THREE.GridHelper(10, 10);
      //   scene.add(gridHelper);

      //   const axesHelper = new THREE.AxesHelper(5);
      //   scene.add(axesHelper);

      // animate
      const clock = new THREE.Clock();

      let nextBlinkTime = 0;
      let blinkDuration = 0.1; // seconds the eye stays closed
      let isBlinking = false;
      let blinkStartTime = 0;

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();

        if (currentMixer) {
          currentMixer.update(deltaTime);
        }

        if (currentVrm) {
          const time = clock.elapsedTime;

          // Start a new blink if it's time
          if (!isBlinking && time > nextBlinkTime) {
            isBlinking = true;
            blinkStartTime = time;
            blinkDuration = 0.05 + Math.random() * 0.1; // random duration 0.05–0.15s
            nextBlinkTime = time + 1 + Math.random() * 3; // next blink 1–4s after this one
          }

          let blinkValue = 0; // eyes open

          if (isBlinking) {
            // progress from 0 to 1 for the blink
            let t = (time - blinkStartTime) / blinkDuration;
            if (t >= 1) {
              t = 1;
              isBlinking = false; // blink finished
            }
            blinkValue = Math.sin(Math.PI * t); // smooth open-close
          }

          currentVrm.expressionManager.setValue("blinkLeft", blinkValue);
          currentVrm.expressionManager.setValue("blinkRight", blinkValue);

          currentVrm.update(deltaTime);
        }

        renderer.render(scene, camera);
      }

      animate();

      // gui
      //   const gui = new GUI();

      //   const params = {
      //     timeScale: 1.0,
      //   };

      //   gui.add(params, "timeScale", 0.0, 2.0, 0.001).onChange((value) => {
      //     currentMixer.timeScale = value;
      //   });

      // file input

      // dnd handler
      window.addEventListener("dragover", function (event) {
        event.preventDefault();
      });

      window.addEventListener("drop", function (event) {
        event.preventDefault();

        // read given file then convert it to blob url
        const files = event.dataTransfer.files;
        if (!files) return;

        const file = files[0];
        if (!file) return;

        const fileType = file.name.split(".").pop();
        const blob = new Blob([file], { type: "application/octet-stream" });
        const url = URL.createObjectURL(blob);

        if (fileType === "fbx") {
          loadFBX(url);
        } else {
          loadVRM(url);
        }
      });

      // mouse listener
      window.addEventListener("mousemove", (event) => {
        lookAtTarget.position.x =
          10.0 *
          ((event.clientX - 0.5 * window.innerWidth) / window.innerHeight);
        lookAtTarget.position.y =
          -10.0 *
          ((event.clientY - 0.5 * window.innerHeight) / window.innerHeight);
      });

      document.addEventListener("mouseout", (event) => {
        // If relatedTarget is null, the mouse left the document (browser window/viewport)
        // and event.clientX/Y can help you confirm which edge it left through
        if (!event.relatedTarget && !event.toElement) {
          // Mouse left the browser window
          console.log("Mouse left the screen!");

          // Reset lookAtTarget
          lookAtTarget.position.x = 0;
          lookAtTarget.position.y = 0;
        }
      });
    </script>
  </body>
</html>
